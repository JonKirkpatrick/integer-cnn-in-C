#version 430
#include "SSBO_LAYOUTS_GLSL"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Parameter memory (packed int8 weights)
layout(std430, binding = 0) buffer Params {
    int params[];
};

// Activations ping-pong buffer (packed int8)
layout(std430, binding = 1) buffer Activations {
    int activations[];
};

int load_i8(int idx)
{
    int word = activations[idx >> 2];
    int shift = (idx & 3) * 8;
    int v = (word >> shift) & 0xFF;
    return (v << 24) >> 24;
}

void store_i8(int idx, int v)
{
    int word_idx = idx >> 2;
    int shift = (idx & 3) * 8;

    int mask = ~(0xFF << shift);
    int word = activations[word_idx];
    word = (word & mask) | ((v & 0xFF) << shift);
    activations[word_idx] = word;
}

// Same helpers for params (kept explicit for clarity)
int load_param_i8(int idx)
{
    int word = params[idx >> 2];
    int shift = (idx & 3) * 8;
    int v = (word >> shift) & 0xFF;
    return (v << 24) >> 24;
}

// Uniforms
uniform int input_size;      // number of input features
uniform int output_size;     // number of output neurons
uniform int shift;           // right shift after accumulation
uniform int input_offset;    // int8 index
uniform int output_offset;   // int8 index
uniform int weight_offset;   // int8 index

void main()
{
    uint j = gl_GlobalInvocationID.x; // output neuron

    if (j >= uint(output_size))
        return;

    int acc = 0;

    int w_base = weight_offset + int(j) * input_size;

    for (int i = 0; i < input_size; ++i)
    {
        int x = load_i8(input_offset + i);
        int w = load_param_i8(w_base + i);
        acc += x * w;
    }

    acc >>= shift;
    acc = clamp(acc, -128, 127);

    store_i8(output_offset + int(j), acc);
}