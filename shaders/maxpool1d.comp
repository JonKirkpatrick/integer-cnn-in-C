#version 430
#include "SSBO_LAYOUTS_GLSL"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Ping-pong buffer for activations (packed int8)
layout(std430, binding = 1) buffer Activations {
    int activations[];
};

int load_i8(int idx)
{
    int word = activations[idx >> 2];
    int shift = (idx & 3) * 8;
    int v = (word >> shift) & 0xFF;
    return (v << 24) >> 24; // sign extend
}

void store_i8(int idx, int v)
{
    int word_idx = idx >> 2;
    int shift = (idx & 3) * 8;

    int mask = ~(0xFF << shift);
    int word = activations[word_idx];
    word = (word & mask) | ((v & 0xFF) << shift);
    activations[word_idx] = word;
}

// Uniforms
uniform int num_channels;
uniform int input_time_length;   // length before pooling
uniform int output_time_length;  // length after pooling
uniform int pool_size;           // e.g. 2
uniform int pool_stride;         // e.g. 2
uniform int input_offset;        // int8 index
uniform int output_offset;       // int8 index

void main()
{
    uint c = gl_GlobalInvocationID.y;
    uint t = gl_GlobalInvocationID.x;

    if (c >= uint(num_channels) || t >= uint(output_time_length))
        return;

    int base_in  = input_offset  + int(c) * input_time_length;
    int base_out = output_offset + int(c) * output_time_length;

    int t0 = int(t) * pool_stride;

    int max_val = -128; // int8 minimum

    for (int k = 0; k < pool_size; ++k)
    {
        int ti = t0 + k;
        if (ti < input_time_length)
        {
            int v = load_i8(base_in + ti);
            max_val = max(max_val, v);
        }
    }

    store_i8(base_out + int(t), max_val);
}